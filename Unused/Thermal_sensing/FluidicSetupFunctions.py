import os
import pandas as pd
import numpy as np
from scipy.interpolate import interp1d
from scipy.signal import savgol_filter
from scipy.integrate import cumulative_trapezoid as cumtrapz


def LoadData(Foldernames, Location="//sun/overvelde/group-folder/PROJECTS/Redesigning Hybrid Heart (Jelle)/EXPERIMENTS/FLUIDICS/"):
    """
    Load data generated by the fluidic setup from the folders specified in Foldernames.
    
    Parameters
    ----------
    Foldernames : list, tuple
        Names of the folders you want to extract data from.
    Location : str
        Path to the folder where you store your experiemental data.
        Change the default to your specific needs
            
    Returns
    -------
    Data : list
        A list of dataframes where each dataframe contains the data from a single subfolder.
        Each column contains the data from a single sensor converted to the specified units.
        The column headers correspond to the sensornames.
        The time column is determined using the samplerate.
    Info : dict
        A dictionary with keys: Samplerate, Samplename, and Offset.
        Samplerate is a list containing the samplerates for each subfolder.
        Samplename is a list containing the names given to each subfolder.
        Offset is a list of dictionaries where each dictionary contains the DC offsets that are subtracted per sensor.
    """
    for i, Folder in enumerate(Foldernames):
        subFolders = [f.name for f in os.scandir(Location + Folder) if f.is_dir()]
        Samplenames = [subFolder[16::] for subFolder in subFolders]
        for j, subFolder in enumerate(subFolders):
            print(f"Loading... Folder {i+1} of {len(Foldernames)}, Sample {j+1} of {len(subFolders)}")
            # Get samplerate
            with open(Location + Folder + "/" + subFolder + "/measurement.txt") as f:
                lines = f.readlines()
            Samplerate = int(lines[8][18::])
            # Read data from file
            if os.path.isfile(Location + Folder + "/" + subFolder + "/analogsensorvalues.txt"):
                df = pd.read_csv(Location + Folder + "/" + subFolder + "/analogsensorvalues.txt", sep='\t')
                df.columns = df.columns.str.rstrip(" [V]")
            elif os.path.isfile(Location + Folder + "/" + subFolder + "/analogsensorvalues.bin"):
                line = [line for line in lines if "analogsensorvalues" in line]
                Sensors = [sensor.rstrip(" [V]") for sensor in line[0][99:-1].split(',')]
                types = [(sensor, 'float') for sensor in Sensors]
                dt = np.dtype(types)
                data = np.fromfile(Location + Folder + "/" + subFolder + "/analogsensorvalues.bin", dtype=dt)
                df = pd.DataFrame.from_records(data)
            Offset = {}
            # Remove DC offset, smooth the signal, and transform the voltage data to physical data
            for header in df.columns:
                offset = df[header].head(9*Samplerate).mean()
                Offset[header] = offset
                df[header] = savgol_filter(df[header] - offset, 21, 3)
                if "Brooks" in header:          # Unit: SLPM
                    df[header] = df[header]/2
                elif "flowFesto" in header:     # Unit: SLPM
                    df[header] = 20*df[header]/9.8
                elif "presFesto" in header:     # Unit: bar
                    if header.lstrip("presFesto")[0].isdigit():
                        df[header] = (1+int(header.lstrip("presFesto")[0]))*df[header]/10
                    else:
                        df[header] = 0.2*df[header]
                elif "DigOut" in header:        # Unit: None
                    mask = df[header] > (df[header].max() + df[header].min())/2
                    df.loc[mask, header] = 1
                    df.loc[np.invert(mask), header] = 0
                    df.loc[0:(9*Samplerate), header] = 0
                elif "pressure" in header:      # Unit: Pa
                    df[header] = 4.137e4*df[header]
                elif "MPX" in header:           # Unit: Pa
                    df[header] = int(header.lstrip("MPX")[0:3])*1e3*df[header]/4.5
                elif "AWM" in header:           # Unit: SLPM
                    df[header] = int(header.lstrip("AWM").split('-')[0])*df[header]/4
                elif "HAF" in header:           # Unit: SLPM
                    df[header] = BidirCalibration(df[header], int(header.lstrip("HAF075#").split('-')[0]))
                elif "SSCDP" in header:         # Unit: Pa
                    df[header] = (df[header]*2*int(header.lstrip("SSCDP").split('-')[0])/4)*6.895e3
                else:
                    print("Unknown sensor! " + header)
            df["Time"] = [(x+1)/Samplerate for x in range(df.shape[0])]
            if i == 0 and j == 0:
                Data = [df]
                Info = {
                    "Samplerate":   [Samplerate],
                    "Samplename":   [Samplenames[j]],
                    "Offset":       [Offset]
                    }
            else:
                Data.append(df)
                Info["Samplerate"].append(Samplerate)
                Info["Samplename"].append(Samplenames[j])
                Info["Offset"].append(Offset)
    return Data, Info


def BidirCalibration(RawData, SensorNumber):
    """
    Calibration data to transform the voltage readings from the HAF sensors to mass flow.
    
    Parameters
    ----------
    RawData : 1D ndarray
        Voltage readings from the sensor. Unit: V
    SensorNumber : int
        The number on the physical sensor.
            
    Returns
    -------
    TransformedData : 1D ndarray
        Same size as RawData. Now containing the transformed data. Unit: SLPM
    """
    Scaling = np.array([[0.38282, 0.3714, 0.36387, 0.36214, 0.35884, 0.36865, 0.36521, 0.3578,
                         0.37122, 0.37353, 0.37647, 0.36906, 0.37918, 0.38531, 0.38266, 0.38062],
                       [0.36938, 0.36206, 0.35958, 0.35603, 0.35001, 0.36552, 0.36511, 0.35895,
                        0.36823, 0.3742, 0.37618, 0.35695, 0.35771, 0.35607, 0.3472, 0.36253]])
    Value = np.array([[-2.1326, -1.9307, -1.6937, -1.4243, -1.1604, -0.85779, -0.58919, -0.32136,
                       0.31472, 0.58181, 0.84542, 1.1334, 1.3661, 1.6049, 1.8786, 2.1503],
                     [-2.2067, -1.9765, -1.7104, -1.445, -1.1855, -0.86148, -0.58576, -0.31669,
                      0.31305, 0.57663, 0.84185, 1.167, 1.4434, 1.7318, 2.0662, 2.2534]])
    Interpolant = interp1d(Value[SensorNumber-1], Scaling[SensorNumber-1], kind='cubic')
    TransformedData = RawData*Interpolant(RawData)
    return TransformedData


def dP2Q(Ppre, Pafter, Resistance, cutoff=float(0)):
    """
    Calibration data to transform the pressure drop over a fixed resistance into a mass flow.
    
    Calibration data has been obtained by providing a sweep of constant mass flows
    into each resistance at different downstream pressures while measuring the
    pressures before and after the resistance. The following equation has been used
    to fit the data: deltaP = (a*(Q)^2+b*(Q))/(Pmean/c+1) where deltaP is the difference
    between Ppre and Pafter and Pmean is the average of the two.
    
    Parameters
    ----------
    Ppre : 1D ndarray
        Pressure readings upstream of the resistance. Unit: Pa
    Pafter : 1D ndarray
        with pressure readings downstream of the resistance. Unit: Pa
    Resistance : str
        Name of the fixed resistance used. Needle color + #number
    cutoff : int
        Cutoff value for the deltaP. Any deltaP below this value is set to 0
            
    Returns
    -------
    Q: 1D ndarray
    with mass flow values. Flow from Ppre towards Pafter is positive. Unit: SLPM
    """
    fitresults = {
        "Pink#1":    (8041.8, 1727.7, 96942.5),
        "Pink#2":    (7523.5, 2853.5, 98318.6),
        "Pink#3":    (8332.2, 2035.3, 92811.8),
        "Purple#1":  (15700.8, 5595.5, 99182),
        "Purple#2":  (13804.6, 6593.4, 99317.5),
        "Blue#1":    (35012.4, 12970, 97983.9),
        "Blue#2":    (42917, 12481.2, 97904),
        "Red#1":     (318612.1, 111876.6, 101290.4),
        "Red#2":     (291799.4, 94797.9, 94269.7)
        }
    if Resistance not in fitresults.keys():
        raise KeyError("Invalid Resistance")
    a, b, c = fitresults.get(Resistance)
    Pmean = (Ppre+Pafter)/2
    PDrop = Ppre-Pafter
    PDrop[abs(PDrop) < cutoff] = 0
    Q = np.sign(PDrop)*(-(b - np.sqrt(((c*b**2 + 4*a*c*PDrop + 4*a*PDrop*Pmean)/c))/2*a))
    return Q


def MF2V(MassFlow, Pressure, V0, Time):
    """
    Calculate the geometric volume over time based on initial volume, inflow of mass, 
    pressure and time. Based on ideal gas law: PV = nRT
    
    Parameters
    ---------
    MassFlow : ndarray
        Mass flow into the system. Unit: m^3/s
    Pressure : ndarray
        Pressure inside the system. Unit: Pa
    V0 : float
        Initial geometric volume of the system. Unit: m^3
    Time : ndarray
        Unit: s
        
    Returns
    -------
    Volume : ndarray
        Geometric volume of the system. Unit: m^3
    """
    T0 = 273
    Troom = 293
    Patm = 101325
    MassEqVolume = (V0*T0/Troom)+cumtrapz(MassFlow, Time, initial=0)
    Volume = MassEqVolume*(Patm/(Patm+Pressure))*Troom/T0
    return Volume
